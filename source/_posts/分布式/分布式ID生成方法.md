---
title: 分布式ID生成方法
date: 2018-01-07 17:02:34
tags: 分布式ID
---


### 1. 使用数据库的 auto_increment 来生成全局唯一递增ID

**优点：**
（1）简单，使用数据库已有的功能
（2）能够保证唯一性
（3）能够保证递增性
（4）步长固定
**缺点：**
（1）可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了
（2）扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展
**改进方法：**
（1）增加主库，避免写入单点
（2）数据水平切分，保证各主库生成的ID不重复
![](http://upload-images.jianshu.io/upload_images/3353177-636f805740d6e8a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如上图所述，由1个写库变成3个写库，**每个写库设置不同的auto_increment初始值，以及相同的增长步长**，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…）
改进后的架构保证了可用性，但**缺点**是：
（1）丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，我们的目标是趋势递增，不是绝对递增）
（2）数据库的写压力依然很大，每次生成ID都要访问数据库
###2. 单点批量ID生成服务
分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。
![](http://upload-images.jianshu.io/upload_images/3353177-fa2d8f85b4c683fe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如0。ID生成服务假设每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了，当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6了。
**优点**：
（1）保证了ID生成的绝对递增有序
（2）大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个
**缺点**：
（1）服务仍然是单点
（2）如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4,5，数据库中max-id是5，分配到3时，服务重启了，下次会从6开始分配，4和5就成了空洞，不过这个问题也不大）
（3）虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展
**改进方法**：
单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点（1）：

![image](http://upload-images.jianshu.io/upload_images/3353177-2793ac877c56a982?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived

###3. uuid
上述方案来生成ID，虽然性能大增，但由于是单点系统，总还是存在性能上限的。同时，上述两种方案，不管是数据库还是服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。有没有一种本地生成ID的方法，即高性能，又时延低呢？
uuid是一种常见的方案：string ID =GenUUID();
**优点：**
（1）本地生成ID，不需要进行远程调用，时延低
（2）扩展性好，基本可以认为没有性能上限
**缺点：**
（1）**无法保证趋势递增**
（2）uuid过长，往往用字符串表示，作为主键**建立索引查询效率低**，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）
### 4. 取当前毫秒数
uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？
取当前毫秒数是一种常见方案：uint64 ID = GenTimeMS();
**优点：**
（1）本地生成ID，不需要进行远程调用，时延低
（2）生成的ID趋势递增
（3）生成的ID是整数，建立索引后查询效率高
**缺点：**
（1）**如果并发量超过1000，会生成重复的ID**。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。

###5. snowflake算法
snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机**每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID**，完全能满足业务的需求。


