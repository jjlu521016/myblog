---
title: CMS学习笔记
tags:
  - JVM
toc: true
originContent: >-
  # 一. 什么是cms及cms的适用场景

  1. CMS ：Mostly-Concurrent收集器，也称并发标记清除收集器（Concurrent Mark-Sweep
  GC，CMS收集器），它管理新生代的方式与Parallel收集器和Serial收集器相同，而在老年代则是尽可能得并发执行，每个垃圾收集器周期只有2次短停顿。

  2. CMS的目的： 为了消除Throught收集器和Serial收集器在Full GC周期中的`长时间停顿`。

  3.
  CMS的使用场景：应用需要更快速的响应，不想长时间的停顿，前提条件是你的CPU资源比较丰富的条件下，适合使用CMS收集器。对于实时响应的任务，比如web
  server类似。


  # 二. CMS的过程

  - 初始标记(STW initial mark) 

  - 并发标记(Concurrent marking) 

  - 并发预清理(Concurrent precleaning) 

  - 重新标记(STW remark) 

  - 并发清理(Concurrent sweeping) 

  - 并发重置(Concurrent reset)  


  1. 初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The
  Word)。这个过程从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。 

  <img src="/image/cms/stw.png" />


  2.
  并发标记：由上一个阶段标记过的对象，开始tracing过程，标记所有可达的对象，这个阶段垃圾回收线程和应用线程同时运行，如上图中的黄色的点。在并发标记过程中，应用线程还在跑，因此会导致有些对象会从新生代晋升到老年代、有些老年代的对象引用会被改变、有些对象会直接分配到老年代，这些受到影响的老年代对象所在的card会被标记为dirty，用于重新标记阶段扫描。这个阶段过程中，老年代对象的card被标记为dirty的可能原因，就是下图中绿色的线：

  <img src="/image/cms/Concurrent-marking.png" />


  3.
  并发预清理：预清理，也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：（1）老年代中card为dirty的对象；

  （2）幸存区(from和to)中引用的老年代对象。

  因此，这个阶段也需要扫描新生代+老年代。


  可中断的预清理：这个阶段的目标跟“预清理”阶段相同，也是为了减轻重新标记阶段的工作量。可中断预清理的价值：在进入重新标记阶段之前尽量等到一个Minor
  GC，尽量缩短重新标记阶段的停顿时间。另外可中断预清理会在Eden达到50%的时候开始，这时候离下一次minor
  gc还有半程的时间，这个还有另一个意义，即避免短时间内连着的两个停顿.

  清理步骤后，如果满足下面两个条件，就不会开启可中断的预清理，直接进入重新标记阶段：


  如果不满足上面两个条件，则进入可中断的预清理，可中断预清理可能会执行多次，那么退出这个阶段的出口有两个（源码参见下图）：

  <img src="/image/cms/cms-code.webp" />

  - 设置了CMSMaxAbortablePrecleanLoops，并且执行的次数超过了这个值，这个参数的默认值是0；

  - CMSMaxAbortablePrecleanTime，执行可中断预清理的时间超过了这个值，这个参数的默认值是5000毫秒。


  - 有可能可中断预清理过程中一直没等到Minor
  gc，这时候进入重新标记阶段的话，新生代还有很多活着的对象，就回导致STW变长，因此CMS还提供了CMSScavengeBeforeRemark参数，可以在进入重新标记之前强制进行依次Minor
  gc。

  - Eden的使用空间大于“CMSScheduleRemarkEdenSizeThreshold”，这个参数的默认值是2M； 

  - Eden的使用率大于等于“CMSScheduleRemarkEdenPenetration”，这个参数的默认值是50%。


  5.（STW）重新标记：重新扫描堆中的对象，进行可达性分析,标记活着的对象。这个阶段扫描的目标是：新生代的对象 + Gc Roots +
  前面被标记为dirty的card对应的老年代对象。如果预清理的工作没做好，这一步扫描新生代的时候就会花很多时间，导致这个阶段的停顿时间过长。这个过程是多线程的。


  6. 并发清除：用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达；


  7. 并发重置：CMS内部重置回收器状态，准备进入下一个并发回收周期。
categories:
  - java
date: 2018-12-04 23:06:59
---

# 一. 什么是cms及cms的适用场景
1. CMS ：Mostly-Concurrent收集器，也称并发标记清除收集器（Concurrent Mark-Sweep GC，CMS收集器），它管理新生代的方式与Parallel收集器和Serial收集器相同，而在老年代则是尽可能得并发执行，每个垃圾收集器周期只有2次短停顿。
2. CMS的目的： 为了消除Throught收集器和Serial收集器在Full GC周期中的`长时间停顿`。
3. CMS的使用场景：应用需要更快速的响应，不想长时间的停顿，前提条件是你的CPU资源比较丰富的条件下，适合使用CMS收集器。对于实时响应的任务，比如web server类似。

# 二. CMS的过程
- 初始标记(STW initial mark) 
- 并发标记(Concurrent marking) 
- 并发预清理(Concurrent precleaning) 
- 重新标记(STW remark) 
- 并发清理(Concurrent sweeping) 
- 并发重置(Concurrent reset)  

1. 初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。 
<img src="/image/cms/stw.png" />

2. 并发标记：由上一个阶段标记过的对象，开始tracing过程，标记所有可达的对象，这个阶段垃圾回收线程和应用线程同时运行，如上图中的黄色的点。在并发标记过程中，应用线程还在跑，因此会导致有些对象会从新生代晋升到老年代、有些老年代的对象引用会被改变、有些对象会直接分配到老年代，这些受到影响的老年代对象所在的card会被标记为dirty，用于重新标记阶段扫描。这个阶段过程中，老年代对象的card被标记为dirty的可能原因，就是下图中绿色的线：
<img src="/image/cms/Concurrent-marking.png" />

3. 并发预清理：预清理，也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：（1）老年代中card为dirty的对象；
（2）幸存区(from和to)中引用的老年代对象。
因此，这个阶段也需要扫描新生代+老年代。

可中断的预清理：这个阶段的目标跟“预清理”阶段相同，也是为了减轻重新标记阶段的工作量。可中断预清理的价值：在进入重新标记阶段之前尽量等到一个Minor GC，尽量缩短重新标记阶段的停顿时间。另外可中断预清理会在Eden达到50%的时候开始，这时候离下一次minor gc还有半程的时间，这个还有另一个意义，即避免短时间内连着的两个停顿.
清理步骤后，如果满足下面两个条件，就不会开启可中断的预清理，直接进入重新标记阶段：

如果不满足上面两个条件，则进入可中断的预清理，可中断预清理可能会执行多次，那么退出这个阶段的出口有两个（源码参见下图）：
<img src="/image/cms/cms-code.webp" />
- 设置了CMSMaxAbortablePrecleanLoops，并且执行的次数超过了这个值，这个参数的默认值是0；
- CMSMaxAbortablePrecleanTime，执行可中断预清理的时间超过了这个值，这个参数的默认值是5000毫秒。

- 有可能可中断预清理过程中一直没等到Minor gc，这时候进入重新标记阶段的话，新生代还有很多活着的对象，就回导致STW变长，因此CMS还提供了CMSScavengeBeforeRemark参数，可以在进入重新标记之前强制进行依次Minor gc。
- Eden的使用空间大于“CMSScheduleRemarkEdenSizeThreshold”，这个参数的默认值是2M； 
- Eden的使用率大于等于“CMSScheduleRemarkEdenPenetration”，这个参数的默认值是50%。

5.（STW）重新标记：重新扫描堆中的对象，进行可达性分析,标记活着的对象。这个阶段扫描的目标是：新生代的对象 + Gc Roots + 前面被标记为dirty的card对应的老年代对象。如果预清理的工作没做好，这一步扫描新生代的时候就会花很多时间，导致这个阶段的停顿时间过长。这个过程是多线程的。

6. 并发清除：用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达；

7. 并发重置：CMS内部重置回收器状态，准备进入下一个并发回收周期。