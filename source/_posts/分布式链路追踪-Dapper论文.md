---
title: 分布式链路追踪-Dapper论文简述
tags: []
toc: true
originContent: ''
categories:
  - 链路追踪
date: 2019-03-11 14:08:14
---

# 背景
在现在的微服务系统中，客户端的一次操作往往需要经过多个模块、多个中间件、多台机器的相互协作才能完成。在这一系列的请求中，可能是串行也可能是并行，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何？随着业务系统模型的日趋复杂化，分布式系统中急需一套链路追踪（Trace）系统来解决这些痛点。
<!-- more -->
分布式服务跟踪是整个分布式系统中跟踪一个用户请求的过程，包括数据采集、数据传输、数据存储、数据分析和数据可视化，捕获此类跟踪让我们构建用户交互背后的整个调用链的视图，这是调试和监控微服务的关键工具。
# Dapper简述
说起分布式链路追踪，我们就不得不提到 Dapper，然后就不得不提下面这个图：
![image.png](/images/2019/03/11/21711900-43c1-11e9-a8bd-cb8e5e5e5942.png)
图 1 中 A~E 分别表示五个服务，
1. 用户发起一次 X 请求到前端系统 A，  
2. 然后 A 分别发送 RPC 请求到中间层 B 和 C，  
3. B 处理请求后返回，  
4. C 还要发起两个 RPC 请求到后端系统 D 和 E。
以上完整调用回路中，一次请求需要经过多个系统处理完成，并且追踪系统像是内嵌在 RPC 调用链上的树形结构，然而，我们的核心数据模型不只局限于特定的 RPC 框架，我们还能跟踪其他行为，例如外界的 HTTP 请求，和外部对 Kafka 服务器的调用等。从形式上看，分布式追踪模型使用的 Trace 树形结构来记录请求之间的关系（父子关系、先后顺序等）。


从众多的分布式系统应用中得出的经验，对于分布式追踪系统需要满足至少两点要求：涵盖面的广度和持续的监控。
1. 涵盖广度的重要性不言而喻，因为在使用追踪系统的进行监控时，如果有一小部分没被监控到，那么人们对这个系统是不是值得信任都会产生巨大的质疑。
2. 监控应该是 7x24 小时的，毕竟，系统异常或是那些重要的系统行为有可能出现过一次，就很难甚至不太可能重现。那么，根据这两个明确的需求，可以推出如下几个具体的设计目标：

>低性能损耗 (Low overhead)：分布式在线系统对于性能、资源要求都很严格，Trace 组件必须对服务影响足够小。对于一些高度优化过的服务，即使一点点性能损耗也会很容易察觉到，而且有可能迫使在线服务的部署团队不得不将分布式追踪系统关停。

> 应用级的透明 (Application-level transparency)：应用层开发者不需要对 Trace 组件关心，Trace 嵌入到基础通用库中，提供高稳定性，而如果 Trace 需要应用开发者配合，那可能会引入额外的 bug 导致 Trace 系统更加脆弱。面对当下互联网公司快速迭代的开发环境来说，这一点尤其重要。

> 扩展性 (Scalability)：Google 的服务在线集群数量可想而知，一次检索就可能跨越上百台甚至成千台机器，因此这个 Trace Infrastructure 的扩展性也很重要。

# Trace 和 Span  

Google Dapper 中关于 Trace 的介绍中主要有以下三个主要元素构成：
1. Span：基本工作单元，例如，在一个新建的 Span 中发送一个 RPC 等同于发送一个回应请求给 RPC，Span 通过一个 64 位 ID 唯一标识，Trace 以另一个 64 位 ID 表示。Span 还有其他数据信息，比如摘要、时间戳事件、关键值注释 (Tags)、Span 的 ID、以及进度 ID (通常是 IP 地址)。Span 在不断地启动和停止，同时记录了时间信息，当你创建了一个 Span，你必须在未来的某个时刻停止它。
2. Trace 树：一系列 Span 组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个 Trace 树。
3. Annotation（标注）：用来及时记录一个事件的存在，一些核心 Annotation 用来定义一个请求的开始和结束。
分布式追踪系统要做的就是记录每次发送和接受动作的标识符和时间戳，将一次请求涉及到的所有服务串联起来，只有这样才能清楚记录每次请求的完整调用链。在分布式追踪系统中使用 Trace 表示对一次请求完整调用链的跟踪，将两个服务例如上面图 1 中的服务 A 和服务 B 的请求/响应过程叫做一次 Span。 我们可以看出每一次跟踪 Trace 都是一个树型结构，Span 可以体现出服务之间的具体依赖关系。

对于每个 Trace 树，Trace 都要定义一个全局唯一的 Trace ID，在这个跟踪中的所有 Span 都将获取到这个 Trace ID。 每个 Span 都有一个 Parent Span ID 和它自己的 Span ID。上面图 1 中 A 服务的 Parent Span ID 为空，Span ID 为 1；然后 B 服务的 Parent Span ID 为 1，Span ID 为 2；C 服务的 Parent Span ID 也为 1，Span ID 为 3，依次类推。
详细的说明请参考下面的几篇文章，这几篇文章描述的都很详细
参考资料:
- [Dapper论文](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36356.pdf)
- [IBM](https://www.ibm.com/developerworks/cn/web/wa-distributed-systems-request-tracing/index.html)
- [Dapper论文翻译版](https://bigbully.github.io/Dapper-translation/)